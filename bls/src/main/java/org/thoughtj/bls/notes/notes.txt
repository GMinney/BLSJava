Standard arrays are static in java: []
Dynamic arrays can be made with ArrayList<> - Can be used to replace the std::vector type in cpp

    // Privatekey is a 256bit unsigned number that is any number from 0 to n-1 where n is the number of points on the eliptic curve.
    // Keygen will take in a seed (a random bit of computer info to generate) and output a private key | inputs: seed | outputs: secret key (sk) 32bytes or 256bits
    // getG1Element is called on a preexisting private key to derive the public key | inputs: secret key (sk) 256bits | outputs: public key (pk) 48 bytes or 384 bits
    // getG2Element is called on a preexisting private key along with a message to create a signature | inputs: secret key (sk) 256bits | outputs: signature 96 bytes or 768 bits

This library is a pure java implementation of BLS12-381
    It primarily uses the BigInteger library to store large bit values
    It also uses ByteBuffers to preallocate some byte arrays
    It also uses slf4j to conduct logging

This library needs to prevent "rouge key" attacks


https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-10#name-bls-curves-for-the-128-bit-

The pairing-based protocols, such as the BLS signatures, use a scalar multiplication
    in G_1, G_2 and an exponentiation in G_3 with the secret key.

In order to prevent the leakage of secret key due to side channel attacks,
    implementors should apply countermeasure techniques such as montgomery ladder
    when they implement modules of a scalar multiplication and an exponentiation.

When converting between an element in extension field and an octet string, implementors
    should check that the coefficient is within an appropriate range [IEEE1363].
    If the coefficient is out of range, there is a possible that security vulnerabilities
    such as the signature forgery may occur.




CORE OPERATIONS
    KeyGen
    SkToPk
    KeyValidate
    CoreSign
    CoreVerify
    Aggregate
    CoreAggregateVerify


SCHEMES
    Schemes exist as [CoreMPL, AugSchemeMPL, BasicSchemeMPL, PopSchemeMPL, LegacySchemeMPL]
        Aug refers to Message-augmentation
        Pop refers to proof-of-possession
        Pop refers to proof-of-possession
        Basic schemes are 'basic'

    MPL refers to 'Minimum public key sizes'

    KeyGen uses HKDF instantiated with the hash function H to generate keys.
    For security, IKM MUST be infeasible to guess, e.g., generated by a trusted source of randomness. IKM MUST be at least 32 bytes long, but it MAY be longer.

    KeyGen takes two parameters. The first parameter, salt, is required; see below for further discussion of this value. The second parameter, key_info, is optional;
    it MAY be used to derive multiple independent keys from the same IKM. By default, key_info is the empty string


Elliptical Curve Arithmetic

Point Addition
    Description: Given two points P and Q on an elliptic curve, the sum of P + Q is another point on the curve.

    Geometric Interpretation: Imagine drawing a straight line through P and Q on the elliptic curve. This line will
     intersect the curve at a third point, which is the result of the addition.

    Formulas: The formulas for point addition are based on the slope of the line passing through P and Q

    Example:    Slope(m) = (yQ - yP) / (xQ - xP)
                xR = (m^2) - xP - xQ
                yR = m(xP - xR) - yP
                Point R = (xR, yR)


Point Doubling:

Description: Given a point P on an elliptic curve, the doubling operation 2P produces another point on the curve that is the result of adding P to itself.

Geometric Interpretation: It involves finding the tangent line to the curve at point P and determining the intersection of this line with the curve.

Formulas:   Equation of curve is often represented as y^2 = x^3 + ax + b
            a and b are coefficients specific to the curve being used

    Example:    Slope(m) = (3xP^2 + a) / (2yP)
                x2P = m^2 - 2xP
                y2P = m(xP - x2P) - yP
                Point 2P = (x2P, y2P)


Scalar Multiplication:

    Description: Scalar multiplication involves multiplying a point P by an integer k. It's essentially the repeated addition of P to itself k times.

    Algorithm: One common algorithm for scalar multiplication is the double-and-add method. It involves expressing k in binary and using the binary digits to guide the operations.

    Pseudocode:
        Q = O  # Point at infinity (neutral element)
        for i = log2(k) down to 0:
            Q = 2 * Q
            if k_i == 1:
                Q = Q + P

    O is the point at infinity, acting as the additive identity.




Field Operations (add(done), sub(done), mul(done), neg(done), inv(done), to/from Montgomery(done), sqrt(done))
Curve Operations (add(done), double(done), mul(done), to/from affine, group check)
Intermediate (hash to curve, pairing, serdes)
BLS12-381 signature (sign, verify, aggregate)


 Applications that instantiate multiple, independent instances of
   either hash_to_curve or encode_to_curve MUST enforce domain
   separation between those instances.


hash_to_field(msg, count)

      Inputs:
      - msg, a byte string containing the message to hash.
      - count, the number of elements of F to output.

      Outputs:
      - (u_0, ..., u_(count - 1)), a list of field elements.

map_to_curve(u)

      Input: u, an element of field F.
      Output: Q, a point on the elliptic curve E.

clear_cofactor
      The function clear_cofactor sends any point on the curve E to the
      subgroup G of E.  Section 7 describes methods to perform this
      operation.

      clear_cofactor(Q)

      Input: Q, a point on the elliptic curve E.
      Output: P, a point in G.


encode_to_curve is a nonuniform encoding from byte strings to points in G

      Input: msg, an arbitrary-length byte string.
            Output: P, a point in G.

            Steps:
            1. u = hash_to_field(msg, 1)
            2. Q = map_to_curve(u[0])
            3. P = clear_cofactor(Q)
            4. return P

hash_to_curve is a uniform encoding from byte strings to points in G

          hash_to_curve(msg)

          Input: msg, an arbitrary-length byte string.
          Output: P, a point in G.

          Steps:
          1. u = hash_to_field(msg, 2)
          2. Q0 = map_to_curve(u[0])
          3. Q1 = map_to_curve(u[1])
          4. R = Q0 + Q1              # Point addition
          5. P = clear_cofactor(R)
          6. return P

Should probably make everything snake case for readability



substr()
ceil()
strxor()
is_square()
sgn0()
inv0()

pairing()
frobenius(x)





